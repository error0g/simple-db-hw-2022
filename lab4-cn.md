# 6.5830/6.5831 实验室 4：SimpleDB 事务

**分配：**2022 年 10 月 24 日星期一

**到期日期：**美国东部时间 2022 年 11 月 9 日星期三晚上 11:59

在这个实验室中，你将在 SimpleDB 中实现一个简单的基于锁定的事务系统。你需要在代码中的适当位置添加锁定和解锁调用，以及跟踪每个交易持有的锁定并根据需要授予交易锁定的代码。

本文档的其余部分描述了添加事务支持所涉及的内容，并提供了如何将此支持添加到数据库的基本概述。

与之前的实验室一样，我们建议你尽早开始。锁定和事务可能很难调试！

##  1. 开始

------

**更新（2022年9月11日）：**如果你在 11 月 9 日或之后启动此实验室，你将从此存储库中获得的代码将包括启动代码和以后实验室的测试。若要仅获取用于实验室 4 的代码和测试的子集，请切换到 `lab4` 分支（ `git checkout lab4`）。

------


你应该从为 Lab 3 提交的代码开始（如果你没有为 Lab 3 提供代码，或者你的解决方案无法正常工作，请联系我们讨论选项）。此外，我们为这个实验室提供了额外的测试用例，这些用例不在你收到的原始代码分发中。我们重申，我们提供的单元测试是为了帮助指导你的实现，但它们并不旨在全面或建立正确性。

你需要将这些新文件添加到你的版本中。最简单的方法是更改到你的项目目录（可能称为 simple-db-hw-2022），并从 GitHub 主存储库中提取：


```
$ cd simple-db-hw-2022
$ git pull upstream main
```

##  2. 事务、锁定和并发控制

在开始之前，你应该确保了解什么是事务，以及严格的两阶段锁定（你将使用它来确保事务的隔离性和原子性）是如何工作的。

在本节的剩余部分中，我们简要概述了这些概念，并讨论了它们与 SimpleDB 的关系。

###  2.1. 交易

事务是一组执行的数据库操作（例如，插入、删除和读取）*原子地*；也就是说，要么所有操作都完成了，要么没有完成，而且对于数据库的外部观察者来说，这些操作不是作为单个不可分割操作的一部分完成的并不明显。

###  2.2. 酸的财产

为了帮助你了解 SimpleDB 中事务管理的工作原理，我们简要回顾了它如何确保满足 ACID 财产：

* ＜ gt r ＝“9”/＞：严格的两阶段锁定和谨慎的缓冲区管理确保了原子性。
* ＜ gt r ＝“10”/＞：由于原子性，数据库是事务一致的。SimpleDB 中没有解决其他一致性问题（例如，关键约束）。
* **隔离**：严格的两阶段锁定提供隔离。
* **耐久性**：FORCE 缓冲区管理策略可确保耐用性（请参阅下文第 2.3 节）。


###  2.3. 恢复和缓冲区管理

为了简化你的工作，我们建议你实施无 STEAL/FORCE 缓冲区管理策略。

正如我们在课堂上讨论的那样，这意味着：

*  如果脏的（更新的）页面被未提交的事务锁定，则不应该将它们从缓冲池中逐出（这是 NO STEAL）。
*  在事务提交时，应该将脏页面强制写入磁盘（例如，将页面写出来）（这就是 force）。
   
为了进一步简化你的生活，你可以假设 SimpleDB 在处理 `transactionComplete` 命令时不会崩溃。请注意，这三点意味着你不需要在这个实验室中实现基于日志的恢复，因为你永远不需要撤消任何工作（你永远不会驱逐脏页面），也永远不需要重做任何工作（在提交时强制更新，并且在提交处理过程中不会崩溃）。

###  2.4. 授予锁

你需要添加对 SimpleDB 的调用（例如，在 `BufferPool` 中），以允许调用方代表特定事务请求或释放特定对象的（共享或独占）锁。

我们建议以*页*粒度进行锁定；为了简化测试，请不要实现表级锁定（尽管这是可能的）。本文档的其余部分和我们的单元测试假设页面级锁定。

你将需要创建数据结构来跟踪每个事务持有哪些锁，并检查是否应在请求时向事务授予锁。

你需要实现共享锁和独占锁；回想一下，这些工作如下：

*  在事务可以读取对象之前，它必须有一个共享锁。
*  在事务可以写入对象之前，它必须有一个独占锁。
*  多个事务可以对一个对象具有共享锁。
*  只有一个事务可以对一个对象具有独占锁定。
*  如果事务*吨*是唯一对对象持有共享锁的事务，则*哦*可能会将其对的锁定锁定为独占锁。

如果事务请求一个无法立即授予的锁，则你的代码应*块*，等待该锁可用（即，由另一个运行在不同线程中的事务释放）。请注意锁实现中的竞争条件——考虑对锁的并发调用可能会如何影响行为。你可能希望阅读 Java 中的[线程同步](http://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html)。

---

**练习1。**

在 BufferPool 中编写获取和释放锁的方法。假设你使用的是页面级锁定，则需要完成以下操作：

*  修改 `getPage()` 以在返回页面之前阻止并获取所需的锁定。
*  实施 `unsafeReleasePage()`。此方法主要用于测试，并在事务结束时使用。
*  实现 `holdsLock()`，以便练习 2 中的逻辑可以确定页面是否已被事务锁定。

你可能会发现定义一个 `LockManager` 类很有帮助，该类负责维护事务和锁的状态，但设计决策取决于你。

在代码通过 `LockingTest` 中的单元测试之前，你可能需要实现下一个练习。

---

###  2.5. 锁定寿命

你将需要实现严格的两阶段锁定。这意味着，事务应该在访问任何对象之前获取该对象的适当类型的锁，并且在事务提交之前不应该释放任何锁。

幸运的是，SimpleDB 的设计可以在读取或修改 `BufferPool.getPage()` 中的页面之前获得这些页面的锁。因此，我们建议在 `getPage()` 中获取锁，而不是在每个运算符中添加对锁定例程的调用。根据你的实现，你可能不必在其他任何地方获取锁。这取决于你来验证！

在读取之前，你需要在任何页面（或元组）上获取*共享*锁，在写入之前，你也需要在任何页（或元组”上获取<gtr gtr="34">锁。你会注意到，我们已经在 BufferPool 中传递了 `Permissions` 对象；这些对象指示调用方希望对正在访问的对象拥有的锁的类型（我们已经为你提供了 `Permissions` 类的代码。）

请注意，你的 `HeapFile.insertTuple()` 和 `HeapFile.deleteTuple()` 的实现，以及返回的迭代器的实现，应该使用 `BufferPool.getPage()` 访问页面。仔细检查 `getPage()` 的这些不同用法是否通过了正确的权限对象（例如， `Permissions.READ_WRITE` 或 `Permissions.READ_ONLY`）。你可能还希望仔细检查你的 `BufferPool.insertTuple()` 和 `BufferPool.deleteTupe()` 的实现是否在它们访问的任何页面上调用了 `markDirty()`（当你在实验室 2 中实现此代码时，你应该这样做，但我们没有测试这种情况。）

在获得锁之后，你还需要考虑何时释放它们。很明显，你应该在事务提交或中止后释放与事务相关的所有锁，以确保严格的 2PL。然而，在其他情况下，在事务结束之前释放锁可能会很有用。例如，你可以在扫描页面以查找空插槽后释放页面上的共享锁（如下所述）。

---

**练习2。**

确保你在整个 SimpleDB 中获取并释放锁。你应该验证的一些（但不一定全部）操作是否正常工作：

*  在 SeqScan 过程中读取页面的元组（如果你在 `BufferPool.getPage()` 中实现了锁定，只要你的 `HeapFile.iterator()` 使用，这应该可以正常工作。）
*  通过 BufferPool 和 HeapFile 方法插入和删除元组（如果你在 `BufferPool.getPage()` 中实现了锁定，只要 `HeapFile.insertTuple()` 和使用，这应该可以正常工作。）

在以下情况下，你还需要特别仔细地考虑获取和释放锁：

*  向 `HeapFile` 添加新页面。你什么时候将页面物理写入磁盘？是否存在与其他事务（在其他线程上）的竞争条件，这些条件可能需要在 HeapFile 级别上特别注意，而不考虑页面级别的锁定？
*  寻找一个可以插入元组的空插槽。大多数实现都会扫描页面以查找空插槽，并且需要 READ_ONLY 锁来执行此操作。然而，令人惊讶的是，如果交易*吨*在页面上找不到空闲插槽*p*，则*吨*可能会立即解除对*p*的锁定。尽管这显然与两阶段锁定的规则相矛盾，但这是可以的，因为*吨*没有使用页面中的任何数据，因此并发事务 t'*哪个更新了p*不可能影响的答案或结果。

此时，你的代码应该通过 `LockingTest` 中的单元测试。

---

###  2.6. 实施 NO STEAL

事务中的修改只有在提交之后才会写入磁盘。这意味着我们可以通过丢弃脏页并从磁盘中重新读取它们来中止事务。因此，我们决不能驱逐脏页面。这项政策被称为“禁止偷窃”。

你需要修改 `BufferPool` 中的方法。特别是，它决不能驱逐脏页面。如果你的驱逐政策更喜欢脏页面进行驱逐，你必须找到驱逐其他页面的方法。如果缓冲池中的所有页面都是脏的，则应该抛出一个 `DbException`。如果你的驱逐策略驱逐了一个干净的页面，请注意事务可能已经保留在被驱逐的页面上的任何锁，并在你的实现中适当地处理它们。

---

**练习3。**

在 `BufferPool` 中的方法中，在不驱逐脏页的情况下实现页面驱逐所需的逻辑。

***


###  2.7. 交易

在 SimpleDB 中，在每个查询的开头都会创建一个 `TransactionId` 对象。该对象被传递给查询中涉及的每个运算符。查询完成后，将调用 `BufferPool` 方法 `transactionComplete()`。

将此方法调用*提交*或*中止*事务，由参数标志指定。在执行过程中的任何时候，运算符都可能引发 `TransactionAbortedException` 异常，这表明发生了内部错误或死锁。我们为你提供的测试用例创建适当的＜ gt r ＝“74”/＞对象，以适当的方式将它们传递给你的运算符，并在查询完成时调用＜ gt r=“75”/＞。我们还实施了 `TransactionId`。

---

**练习4。**

在 `BufferPool` 中实现 `transactionComplete()` 方法。请注意，transactionComplete 有两个版本，一个接受额外的布尔值**犯罪**参数，另一个不接受。没有附加参数的版本应该始终提交，因此可以通过调用 `transactionComplete(tid, true)` 来简单地实现。

提交时，应将与事务相关联的脏页刷新到磁盘。中止时，应通过将页面恢复到磁盘上的状态来恢复事务所做的任何更改。

无论事务是提交还是中止，你都应该释放 `BufferPool` 保持的关于事务的任何状态，包括释放事务持有的任何锁。

此时，你的代码应该通过 `TransactionTest` 单元测试和系统测试。你可能会发现 `TransactionTest{One, Two Five, Ten, AllDirty}` 系统测试很有说明性，但在你完成下一个练习之前，它们很可能会失败。

###  2.8. 死锁和中止

SimpleDB 中的事务可能会死锁（如果你不明白原因，我们建议你阅读 Ramakrishnan&Gehrke 中关于死锁的内容）。你需要检测到这种情况并抛出 `TransactionAbortedException`。

有许多可能的方法可以检测死锁。strawperson 的一个例子是实现一个简单的超时策略，如果事务在给定的时间段后没有完成，该策略就会中止事务。对于真正的解决方案，你可以在依赖图数据结构中实现循环检测，如讲座中所示。在这个方案中，你将定期或每当你试图授予新锁时检查依赖关系图中的循环，并在存在循环的情况下中止某些操作。在检测到存在死锁之后，你必须决定如何改善这种情况。假设你在事务*吨*等待锁定时检测到死锁。如果你感到杀人，你可能会中止**全部的**正在等待的交易；这可能会导致大量工作未完成，但你可以保证*吨*会取得进展。或者，你可以决定中止*吨*，让其他事务有机会取得进展。这意味着最终用户将不得不重试事务*吨*。

另一种方法是使用事务的全局排序来避免构建等待图。出于性能原因，这有时是首选，但在这种方案下，本可以成功的事务可能会被错误地中止。示例包括 WAIT-DIE 和 WOUND-WAIT 方案。

---

**练习5。**

在 `src/simpledb/BufferPool.java` 中实现死锁检测或预防。你有许多死锁处理系统的设计决策，但没有必要做一些非常复杂的事情。我们希望你在每次交易中都能做得比简单的超时更好。一个好的起点是在每次锁定请求之前在等待图中实现循环检测，这样的实现将获得充分的赞誉。请在实验室写作中描述你的选择，并列出你的选择与其他选择相比的利弊。

你应该通过抛出 `TransactionAbortedException` 异常来确保在发生死锁时代码正确中止事务。此异常将被执行事务的代码捕获（例如， `TransactionTestUtil.java`），该代码应在事务结束后调用 `transactionComplete()` 进行清理。你不需要自动重新启动由于死锁而失败的事务——你可以假设更高级别的代码会处理这一问题。

我们在 `test/simpledb/DeadlockTest.java` 中提供了一些（非单元）测试。它们实际上有点涉及，所以运行可能需要几秒钟以上的时间（取决于你的策略）。如果它们似乎无限期地挂起，那么你可能有一个尚未解决的僵局。这些测试构建了简单的死锁情况，你的代码应该能够逃离这些情况。

请注意，在 `DeadLockTest.java` 的顶部附近有两个定时参数；这些确定了测试检查是否已获取锁的频率，以及重新启动中止事务之前的等待时间。如果使用基于超时的检测方法，则可以通过调整这些参数来观察不同的性能特征。测试将向控制台输出与已解决的死锁相对应的 `TransactionAbortedExceptions`。

你的代码现在应该通过 `TransactionTest{One, Two, Five, Ten, AllDirty}` 系统测试（根据你的实现，系统测试也可能运行很长时间）。

在这一点上，你应该有一个可恢复的数据库，因为如果数据库系统崩溃（在 `transactionComplete()` 以外的时间点），或者如果用户明确中止事务，则在系统重新启动（或事务中止）后，任何正在运行的事务的影响都将不可见。) 你可能希望通过运行一些事务并显式终止数据库服务器来验证这一点。

---

###  2.9. 设计备选方案

在本实验室的过程中，我们确定了你必须做出的一些实质性设计选择：

*  锁定粒度：页面级别与元组级别
*  死锁处理：检测与预防，中止自己与他人。

---

**奖金练习6。（20%的额外信贷）**

对于这些选择中的一个或多个，实现这两个备选方案，并通过实验比较它们的性能特征。在你的写作中包括你的基准测试代码和一个简短的评估（可能有图表）。

你现在已经完成了这个实验室。干得好！

***

##  3. 后勤

你必须提交你的代码（见下文）以及描述你的方法的简短文章（最多 2 页）。该书面报告应：

*  描述你在死锁处理中做出的任何设计决策，并列出你的方法的优缺点。
*  讨论并证明你对 API 所做的任何更改。
*  描述代码中任何缺失或不完整的元素。
*  描述一下你在实验室里花了多长时间，是否有什么特别困难或令人困惑的地方。
*  描述你所做的任何额外的信贷实施。

###  3.1. 协作

这个实验室应该是一个人可以管理的，但如果你更喜欢和伴侣一起工作，这也是可以的。不允许更大的团队。如果有人，请在你的文章中清楚地说明你和谁共事过。

###  3.2. 提交作业

我们将使用 Gradescope 自动升级所有编程作业。你们都应该被邀请到类实例；如果没有，请告诉我们，我们可以帮助你设置。你可以在截止日期前多次提交代码；我们将使用 gradescope 确定的最新版本。将撰写的内容与你提交的内容一起放入一个名为 `lab4-writeup.txt` 的文件中。你还需要显式添加你创建的任何其他文件，例如新的 `*.java` 文件。

如果你与合作伙伴一起工作，则只需要一个人提交到 Gradescope。但是，请确保将另一个人添加到你的群中。还要注意，每个成员都必须有自己的书面记录。请将你的 Kerberos 用户名添加到文件名和写入本身中（例如， `lab4-writeup-username1.txt` 和 `lab4-writeup-username2.txt`）。

提交到 Gradescope 的最简单方法是使用包含代码的 `.zip` 文件。在 Linux/macOS 上，你可以通过运行以下命令来执行此操作：


```bash
$ zip -r submission.zip src/ lab4-writeup.txt

# If you are working with a partner:
$ zip -r submission.zip src/ lab4-writeup-username1.txt lab4-writeup-username2.txt
```

<a name="bugs"></a>
###  3.3. 提交错误

SimpleDB 是一段相对复杂的代码。你很可能会发现错误、不一致、糟糕、过时或不正确的文档等。

因此，我们要求你带着冒险的心态来做这个实验室。如果有些事情不清楚，甚至是错误的，不要生气；相反，试着自己想办法，或者给我们发一封友好的电子邮件。

请向<a href="mailto:6.5830-staff@mit.edu">提交（友好！）错误报告 6.5830-staff@mit.edu</a>。当你这样做时，请尝试包括：

* 错误的描述。
* 一个 `.java` 文件，我们可以将其放在 `test/simpledb` 目录中，编译并运行。
* 一个 `.txt` 文件，其中包含重现错误的数据。我们应该能够使用 `HeapFileEncoder` 将其转换为 `.dat` 文件。

如果你觉得自己遇到了一个 bug，你也可以在 Piazza 的课堂页面上发帖。

###  3.4 分级

50% 的分数将取决于你的代码是否通过系统测试套件，我们将对其进行测试。这些测试将是我们提供的测试的超集。在提交代码之前，你应该确保它不会从 `ant test` 和 `ant systemtest` 中产生错误（通过所有测试）。

**新增：**

* 鉴于此实验室将要求你大量修改早期代码，我们强烈建议你确保你的实现通过早期实验室（尤其是实验室 1 和实验室 2）的测试。如果由于你的实现未通过以前实验室的测试而导致你无法取得进展，请联系我们讨论选项。

* 考虑到这个实验室处理并发问题，我们将在到期日后重新运行 autorader，以阻止尝试错误代码，直到幸运为止。你有责任确保你的代码**可靠地**通过测试。

* 与以前的实验室相比，这个实验室的手动评分比例更高，为 50%。具体来说，如果你的并发处理是伪造的（例如，插入 `Thread.sleep(1000)` 直到竞争消失），我们会非常不高兴。

**重要信息：**在测试之前，Gradescope 将用我们的这些文件版本替换你的 `build.xml`、、 `Parser.java` 以及目录的全部内容。这意味着你无法更改 `.dat` 文件的格式，也无法依赖 `Parser.java` 中的任何自定义功能。你还应该小心更改我们的 API。你应该测试你的代码是否编译了未修改的测试。

提交后，你应该立即从 Gradescope 获得未通过测试的反馈和错误输出（如果有的话）。额外 50% 的分数将基于你的写作质量和我们对你代码的主观评估。这一部分也将在我们为你的作业打分后发布在 Gradescope 上。

我们在设计这项任务时玩得很开心，希望你喜欢黑客！
